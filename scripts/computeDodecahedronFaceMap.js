#!/usr/bin/env node
/**
 * Compute dodecahedron face → star/constellation mapping.
 *
 * Uses Three.js DodecahedronGeometry(1, 0) to get the 12 face centers,
 * then maps every star and constellation to its nearest face using the
 * same lonLatToXYZ projection as StarMap3D.
 *
 * Output: JSON written to src/data/dodecahedronFaceMap.js
 */

const fs = require('fs');
const path = require('path');

// ── Star data ──
const starsNorth = require('../src/data/starsNorth.json');
const starsSouth = require('../src/data/starsSouth.json');
const constellations = require('../src/data/constellations.json');

const DEG2RAD = Math.PI / 180;

function lonLatToXYZ(lon, lat) {
  const raRad = -lon * DEG2RAD;
  const decRad = lat * DEG2RAD;
  return [
    Math.cos(decRad) * Math.cos(raRad),
    Math.sin(decRad),
    Math.cos(decRad) * Math.sin(raRad),
  ];
}

// ── Dodecahedron geometry (inline, no Three.js dep for Node) ──
// A regular dodecahedron has 20 vertices and 12 pentagonal faces.
// The 12 face centers of a dodecahedron are the 12 vertices of its dual
// icosahedron. Golden ratio φ = (1+√5)/2.

const PHI = (1 + Math.sqrt(5)) / 2;

// Icosahedron vertices (= dodecahedron face centers), normalised to unit sphere
const rawIcoVerts = [
  [ 0,  1,  PHI],
  [ 0, -1,  PHI],
  [ 0,  1, -PHI],
  [ 0, -1, -PHI],
  [ 1,  PHI, 0],
  [-1,  PHI, 0],
  [ 1, -PHI, 0],
  [-1, -PHI, 0],
  [ PHI, 0,  1],
  [-PHI, 0,  1],
  [ PHI, 0, -1],
  [-PHI, 0, -1],
];

function normalise(v) {
  const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
  return [v[0]/len, v[1]/len, v[2]/len];
}

const faceCenters = rawIcoVerts.map(v => normalise(v));

function dot(a, b) {
  return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function nearestFace(xyz) {
  let best = -1, bestDot = -Infinity;
  for (let i = 0; i < faceCenters.length; i++) {
    const d = dot(xyz, faceCenters[i]);
    if (d > bestDot) { bestDot = d; best = i; }
  }
  return best;
}

// ── Map stars ──
const allStars = starsNorth.concat(starsSouth);
const faceStarCounts = new Array(12).fill(0);
const faceStarIndices = Array.from({ length: 12 }, () => []);

for (let i = 0; i < allStars.length; i++) {
  const [lon, lat] = allStars[i];
  const xyz = lonLatToXYZ(lon, lat);
  const face = nearestFace(xyz);
  faceStarCounts[face]++;
  faceStarIndices[face].push(i);
}

// ── Map constellations (by centroid of line endpoints) ──
const faceConstellations = Array.from({ length: 12 }, () => []);

for (const c of constellations) {
  // Compute centroid of all line-segment endpoints
  let sx = 0, sy = 0, sz = 0, n = 0;
  for (const seg of c.lines) {
    for (const pt of seg) {
      const xyz = lonLatToXYZ(pt[0], pt[1]);
      sx += xyz[0]; sy += xyz[1]; sz += xyz[2]; n++;
    }
  }
  if (n === 0) continue;
  const centroid = normalise([sx/n, sy/n, sz/n]);
  const face = nearestFace(centroid);
  faceConstellations[face].push({ id: c.id, name: c.name });
}

// ── Compute face center lat/lon for labelling ──
function xyzToLonLat(xyz) {
  const lat = Math.asin(xyz[1]) / DEG2RAD;
  const lon = -Math.atan2(xyz[2], xyz[0]) / DEG2RAD;
  return { lat: Math.round(lat * 10) / 10, lon: Math.round(lon * 10) / 10 };
}

// ── Build output ──
const faces = faceCenters.map((center, i) => {
  const ll = xyzToLonLat(center);
  return {
    face: i,
    center: { x: +center[0].toFixed(4), y: +center[1].toFixed(4), z: +center[2].toFixed(4) },
    latDeg: ll.lat,
    lonDeg: ll.lon,
    starCount: faceStarCounts[i],
    constellations: faceConstellations[i].map(c => c.name).sort(),
    constellationIds: faceConstellations[i].map(c => c.id).sort(),
  };
});

// ── Write JS module ──
const outPath = path.join(__dirname, '..', 'src', 'data', 'dodecahedronFaceMap.js');
const content = `/**
 * Dodecahedron Face → Star / Constellation Map
 *
 * Generated by scripts/computeDodecahedronFaceMap.js
 *
 * Each of the 12 pentagonal faces of the dodecahedron maps to a region
 * of the celestial sphere. Stars and constellations are assigned to the
 * nearest face center (the 12 vertices of the dual icosahedron).
 *
 * The mapping is projection-independent — it uses the same lonLatToXYZ
 * conversion as StarMap3D, so the assignment is identical in geocentric
 * and heliocentric views.
 *
 * Total stars: ${allStars.length}
 * Total constellations: ${constellations.length}
 */

const DODECAHEDRON_FACE_MAP = ${JSON.stringify(faces, null, 2)};

export default DODECAHEDRON_FACE_MAP;
`;

fs.writeFileSync(outPath, content, 'utf8');
console.log(`Wrote ${outPath}`);
console.log(`\nSummary:`);
console.log(`  Total stars: ${allStars.length}`);
console.log(`  Total constellations: ${constellations.length}`);
console.log();
for (const f of faces) {
  console.log(`  Face ${f.face} (lat=${f.latDeg}° lon=${f.lonDeg}°): ${f.starCount} stars, ${f.constellations.length} constellations`);
  console.log(`    ${f.constellations.join(', ')}`);
}
